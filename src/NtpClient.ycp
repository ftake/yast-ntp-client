/**
 * File:	modules/NtpClient.ycp
 * Package:	Configuration of ntp-client
 * Summary:	Data for configuration of ntp-client, input and output functions.
 * Authors:	Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of ntp-client.
 * Input and output routines.
 */

{

module "NtpClient";
textdomain "ntp-client";

import "Mode";
import "NetworkDevices";
import "Package";
import "Progress";
import "Report";
import "Service";
import "Summary";
import "SuSEFirewall";


/**
 * Abort function
 * return boolean return true if abort
 */
global boolean() AbortFunction = nil;

/**
 * Data was modified?
 */
global boolean modified = false;

/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
global boolean write_only = false;

/**
 * Read all ntp-client settings
 * @return true on success
 */
global list<map<string, any> > ntp_records = [];


/**
  * Should the daemon be started when system boots?
  */
global boolean run_service = false;

/**
  * Should the daemon be started in chroot environment?
  */
global boolean run_chroot = false;

/**
  * Index of the currently sellected item
  */
global integer selected_index = -1;

/**
  * The currently sellected item
  */
global map<string,any> selected_record = $[];

/**
  * Should the firewall settings be changed?
  */
global boolean change_firewall = false;

/**
  * Map containing settings of the firewall - keys INT, EXT, DMZ
  */
global map firewall_settings = $[];

/**
  * Required packages
  */
global list required_packages = ["xntp"];

global define list<map<string,any> >getSyncRecords ();
global define boolean storeSyncRecord ();
global define boolean deleteSyncRecord (integer index);
global define boolean selectSyncRecord (integer index);
global define boolean Write ();

global boolean simple_dialog = false;

include "ntp-client/misc.ycp";
include "ntp-client/widgets.ycp";

global map<string,any> widgets = InitWidgets ();

/**
 * Read all ntp-client settings
 * @return true on success
 */
global define boolean Read() ``{

    /* NtpClient read dialog caption */
    string caption = _("Initializing NTP Client Configuration");

    integer steps = 2;
    integer sl = 500;

    // We do not set help text here, because it was set outside
    Progress::New( caption, " ", steps, [
	    // progress stage
	    _("Read network configuration"),
	    // progress stage
	    _("Read NTP settings"),
	], [
	    // progress step
	    _("Reading network configuration..."),
	    // progress step
	    _("Reading NTP settings..."),
	    // progress step
	    _("Finished")
	],
	""
    );

    // read network configuration
    if(Abort()) return false;
    Progress::NextStage();

    Progress::off ();
    NetworkDevices::Read ();
    Progress::on ();

    // read current settings
    if(Abort()) return false;
    Progress::NextStage();

    boolean failed = false;

    if (! Package::Installed ("xntp") && !Mode::config)
    {
	boolean install_ok = Package::Install ("xntp");
	if (! install_ok && ! Package::LastOperationCanceled ())
	{
	    // error popup
	    Report::Error (_("Installing required packages failed."));
	}
    }

    run_service = Service::Enabled ("xntpd");

    map conf = (map)SCR::Read (.etc.ntp_conf.all);
    if (conf == nil)
    {
	failed = true;
	conf = $[];
    }
    list<map<string, any> > value = conf["value"]:[];
    integer index = -1;
    ntp_records = maplist (map<string, any> m, value, ``{
	index = index + 1;
	string type = m["name"]:"";
	string address = m["value"]:"";
	string options = "";
	if (contains ([
	    "server", "peer", "broadcast", "broadcastclient", "manycast",
	    "manycastclient", "fudge" ],
	    type))
	{
	    list<string> l = splitstring (address, " \t");
	    l = (list<string>)filter (string s, l, ``(s != ""));
	    address = l[0]:"";
	    l[0] = "";
	    options = mergestring (l, " ");
	}
	map<string,any> entry = $[
	    "type" : type,
	    "address" : address,
	    "options" : options,
	    "comment" : m["comment"]:"",
	];
	return entry;
    });
    list<map<string, any> > fudge_records = filter (map<string,any> m, ntp_records, ``(
	m["type"]:"" == "fudge"
    ));
    map <string, map<string, any> > fudge_map = (map <string, map<string, any> >)listmap (map m, fudge_records,
    ``{
	string key = m["address"]:"";
	return $[key: m];
    });
    ntp_records = filter (map<string,any> m, ntp_records, ``(
	m["type"]:"" != "fudge"
    ));

    ntp_records = (list<map<string,any> >)maplist (map m, ntp_records, ``{
	if (haskey (fudge_map, m["address"]:""))
	{
	    m["fudge_options"] = fudge_map[m["address"]:"", "options"]:"";
	    m["fudge_comment"] = fudge_map[m["address"]:"", "comment"]:"";
	}
	return m;
    });

    run_chroot = SCR::Read (.sysconfig.xntp.XNTPD_RUN_CHROOTED) == "yes";

    string initial_sync = (string)SCR::Read (.sysconfig.xntp.XNTPD_INITIAL_NTPDATE);
    if (initial_sync == nil)
    {
	initial_sync = "";
	failed = true;
	y2error ("Failed reading .sysconfig.xntp.XNTPD_INITIAL_NTPDATE");
    }

    // mark local clock to be local clock and not real servers
    ntp_records = maplist (map<string,any> p, ntp_records, ``{
	if (p["type"]:"" == "server"
	    && regexpmatch (p["address"]:"", "^127\.127\.[0-9]+.[0-9]+$"))
	{
	    p["type"] = "__clock";
	}
	return p;
    });

    // mark those servers and peers that are used for initial syncing
    if (initial_sync == "AUTO")
    {
	ntp_records = maplist (map<string,any> p, ntp_records, ``{
	    p["initial_sync"] = p["type"]:"" == "server";
	    return p;
	});
    }
    else if (regexpmatch (initial_sync, "AUTO-[0-9]+"))
    {
	integer count = tointeger (
	    regexpsub (initial_sync, "AUTO-([0-9]+)", "\\1"));
	ntp_records = maplist (map<string,any> p, ntp_records, ``{
	    if (p["type"]:"" == "server" || p["type"]:"" == "peer")
	    {
		count = count - 1;
		p["initial_sync"] = count >= 0;
	    }
	    else
		p["initial_sync"] = false;
	    return p;
	});
    }
    else
    {
	list listed = splitstring (initial_sync, " ");
	ntp_records = maplist (map<string,any> p, ntp_records, ``{
	    p["initial_sync"]
		= (p["type"]:"" == "server" || p["type"]:"" == "peer")
		    && contains (listed, p["address"]:"");
	    return p;
	});
    }

    if(failed)
    {
	// error report
	Report::Error(_("Cannot read the current settings."));
    }
    SuSEFirewall::Read ();
    if (SuSEFirewall::start)
    {
	foreach (string i, ["INT", "EXT", "DMZ"], ``{
	    string k1 = sformat ("FW_SERVICES_%1_TCP", i);
	    string k2 = sformat ("FW_SERVICES_%1_UDP", i);
	    string s = SuSEFirewall::settings[k1]:""
		+ " " + SuSEFirewall::settings[k2]:"";
	    list<string> l = splitstring (s, " ");
	    firewall_settings[i] = contains (l, "123");
	});
	y2milestone ("Firewall settings: %1", firewall_settings);
    }

    if(Abort()) return false;
    Progress::NextStage ();
    Progress::Title (_("Finished"));
    sleep(sl);

    if(Abort()) return false;
    modified = false;
    return true;
}

/**
 * Write all ntp-client settings
 * @return true on success
 */
global define boolean Write() ``{

    /* NtpClient read dialog caption */
    string caption = _("Saving NTP Client Configuration");

    integer steps = 2;

    integer sl = 0;
    sleep(sl);

    // We do not set help text here, because it was set outside
    Progress::New(caption, " ", steps, [
	    // progress stage
	    _("Write NTP settings"),
	    // progress stage
	    _("Restart NTP daemon")
	], [
	    // progress step
	    _("Writing the settings..."),
	    // progress step
	    _("Restarting NTP daemon..."),
	    // progress step
	    _("Finished")
	],
	""
    );

    // write settings
    if(Abort()) return false;
    Progress::NextStage();

    y2milestone ("Writing settings %1", ntp_records);

    list<map<string, any> > save2 = (list<map<string, any> >)flatten (maplist (
	map<string, any> r, ntp_records,
    ``{
	map<string,any> s1 = $[
	    "comment" : r["comment"]:"",
	    "kind" : "value",
	    "name" : r["type"]:"",
	    "type" : 0,
	    "value" : r["address"]:"" + " " + r["options"]:"",
	];
	map<string,any> s2 = nil;
	if (r["type"]:"" == "__clock")
	{
	    s2 = $[
		"comment" : r["fudge_comment"]:"",
		"kind" : "value",
		"name" : "fudge",
		"type" : 0,
		"value" : r["address"]:"" + " " + r["fudge_options"]:"",
	    ];
	    s1["name"] = "server";
	}
	return [ s1, s2 ];
    }));
    save2 = filter (map<string, any> m, save2, ``(m != nil));

    boolean failed = false;
    map conf = (map)SCR::Read (.etc.ntp_conf.all);
    if (conf == nil)
    {
        failed = true;
    }
    else
    {
	conf["value"] = save2;
	if (! SCR::Write (.etc.ntp_conf.all, conf))
	    failed = true;
	if (! SCR::Write (.etc.ntp_conf, nil))
	    failed = true;
    }

    if (failed)
	// error report
	Report::Error (_("Cannot write settings to /etc/ntp.conf."));


    list init = maplist (map<string,any> p, ntp_records, ``(
	(p["type"]:"" == "server" || p["type"]:"" == "peer")
	    && p["initial_sync"]:false
		? p["address"]:""
		: nil
    ));
    init = filter (any i, init, ``(i != nil));
    string init_str = mergestring ((list<string>)init, " ");

    // Don't remove the AUTO key, something should be present for initialization
    // if there is no NTP server set explicitly
    if (size (init) == 0)
    {
	string orig_init = (string)SCR::Read (.sysconfig.xntp.XNTPD_INITIAL_NTPDATE);
	if (orig_init == "AUTO" || substring (orig_init, 0, 5) == "AUTO-")
	{
	    init_str = orig_init;
	}
    }

    if (! (SCR::Write (.sysconfig.xntp.XNTPD_RUN_CHROOTED, run_chroot
	    ? "yes"
	    : "no")
	&& SCR::Write (.sysconfig.xntp.XNTPD_INITIAL_NTPDATE, init_str)
	&& SCR::Write (.sysconfig.xntp, nil)))
    {
	// error report
	Report::Error (_("Cannot write sysconfig variables."));
    }

    sleep(sl);

    // restart daemon
    if(Abort()) return false;
    Progress::NextStage ();

    if (change_firewall)
    {
	foreach (string i, ["INT", "EXT", "DMZ"], ``{
	    foreach (string p, ["TCP", "UDP"], ``{
		string k = sformat ("FW_SERVICES_%1_%2", i, p);
		string s = SuSEFirewall::settings[k]:"";
		list<string> l = splitstring (s, " ");
		l = (list<string>)filter (string p, l, ``(p != "123"));
		if (firewall_settings[i]:false)
		    l = (list<string>)add (l, "123");
		s = mergestring (l, " ");
		SuSEFirewall::settings[k] = s;
	    });
	});
	SuSEFirewall::Write ();
    }

    if (! Service::Adjust ("xntpd",
	run_service ? "enable" : "disable"))
    {
	// error report
	Report::Error (_("Cannot adjust the service"));
    }

    if (run_service && (! write_only)
	&& 0 != Service::RunInitScript("xntpd", "restart"))
    {
	// error report
	Report::Error (_("Cannot restart the NTP daemon."));
    }
    if (! run_service)
    {
	Service::RunInitScript("xntpd", "stop");
    }

    sleep(sl);

    if(Abort()) return false;
    Progress::NextStage ();
    Progress::Title (_("Finished"));
    sleep(sl);

    if(Abort()) return false;
    return true;
}

/**
 * Get all ntp-client settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global define boolean Import (map settings) ``{
    run_service = settings["start_at_boot"]:false;
    run_chroot = settings["start_in_chroot"]:true;
    ntp_records = settings["peers"]:[];
    ntp_records = maplist(map<string, any> p, ntp_records, ``{
            if (haskey(p, "key") && haskey(p, "value") )
            {
                p["type"] = p["key"]:"";
                p["address"] = p["value"]:"";
		if (haskey (p, "initial"))
		    p["initial_sync"] = p["initial"]:false;
		if (haskey (p, "param"))
		    p["options"] = p["param"]:"";
                return (p);
            } else {
                return (p);
            }
            });
    modified = true;
    return true;
}

/**
 * Dump the ntp-client settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global define map Export () ``{
    return $[
	"start_at_boot" : run_service,
	"start_in_chroot" : run_chroot,
	"peers" : ntp_records,
    ];
}

/**
 * Create a textual summary and a list of unconfigured cards
 * @return string summary of the current configuration
 */
global define string Summary() ``{
    string summary = "";
    if (run_service)
	// summary string
	summary = Summary::AddLine(summary, _("The NTP daemon starts when starting the system.") );
    else
	// summary string
	summary = Summary::AddLine(summary, _("The NTP daemon does not start automatically.") );

    map types = $[
	// summary string, %1 is list of addresses
	"server" : _("Servers: %1"),
	// summary string, %1 is list of addresses
	"__clock" : _("Radio Clocks: %1"),
	// summary string, %1 is list of addresses
	"peer" : _("Peers: %1"),
	// summary string, %1 is list of addresses
	"broadcast" : _("Broadcast time information to"),
	// summary string, %1 is list of addresses
	"broadcastclient" : _("Accept broadcasted time information from"),
    ];
    foreach (string t, ["server", "__clock", "peer", "broadcast", "broadcastclient" ],
    ``{
	list<map<string,any> > l
	    = filter (map<string,any> p, ntp_records, ``(p["type"]:"" == t));
	list<string> names
	    = maplist (map<string,any> i, l, ``(i["address"]:""));
	names = filter (string n, names, ``(n != ""));
	if (size (names) > 0)
	{
	    summary = Summary::AddLine (summary, sformat (
		types[t]:"", mergestring ((list<string>)names, ", ")
	    ));
	}
    });
    return summary;
}

/**
  * Get the list of synchronization-related records
  * @return a list of maps with keys type (eg. "server"), address and index.
  */
global define list<map<string,any> >getSyncRecords () ``{
    integer index = -1;
    list<map<string,any> > ret = maplist (map m, ntp_records, ``{
	index = index + 1;
	string type = m["type"]:"";
	if (! contains (["server", "peer", "broadcast",
	    "broadcastclient", "__clock"], type))
	{
	    return nil;
	}
	return $[
	    "type" : type,
	    "index" : index,
	    "address" : m["address"]:"",
	    "device" : m["device"]:"",
	];
    });
    ret = filter (map<string,any> m, ret, ``(m != nil));
    return ret;
}

/**
  * Select synchronization record
  * @param index integer, -1 for creating a new record
  * @return boolean true on success
  */
global define boolean selectSyncRecord (integer index) ``{
    boolean ret = true;
    if (index >= size (ntp_records) || index < -1)
    {
	y2error ("Record with index %1 doesn't exist, creating new", index);
	index = -1;
	ret = false;
    }
    if (index == -1)
	selected_record = $[];
    else
	selected_record = ntp_records[index]:$[];
    selected_index = index;
    return ret;
}

/**
  * Find index of synchronization record
  * @param type string record type
  * @param address string address
  * @return integer index of the record if found, -1 otherwise
  */
global define integer findSyncRecord (string type, string address) ``{
    integer index = -1;
    integer ret = -1;
    foreach (map<string,any> m, ntp_records, ``{
	index = index + 1;
	if (type == m["type"]:"" && address == m["address"]:"")
	    ret = index;
    });
    return ret;
}

/**
  * Store currently sellected synchronization record
  * @return boolean true on success
  */
global define boolean storeSyncRecord () ``{
    if (selected_index == -1)
	ntp_records = add (ntp_records, selected_record);
    else
	ntp_records[selected_index] = selected_record;
    modified = true;
    return true;
}

/**
  * Delete specified synchronization record
  * @param index integer index of record to delete
  * @return boolean true on success
  */
global define boolean deleteSyncRecord (integer index) ``{
    if (index >= size (ntp_records) || index <= -1)
    {
	y2error ("Record with index %1 doesn't exist", index);
	return false;
    }
    ntp_records[index] = nil;
    ntp_records = filter (map<string,any> r, ntp_records, ``(r != nil));
    modified = true;
    return true;
}

/**
 * Return required packages for auto-installation
 * @return map of packages to be installed and to be removed
 */
global define map AutoPackages() ``{
	return ($["install": required_packages, "remove": []]);

}

/* EOF */
}
