/**
 * File:	modules/NtpClient.ycp
 * Package:	Configuration of ntp-client
 * Summary:	Data for configuration of ntp-client, input and output functions.
 * Authors:	Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of ntp-client.
 * Input and output routines.
 */

{

module "NtpClient";
textdomain "ntp-client";

import "Progress";
import "Report";
import "Summary";
import "Runlevel";
import "Require";
import "Mode";

include "ntp-client/widgets.ycp";
include "ntp-client/misc.ycp";

global map widgets = InitWidgets ();

/**
 * Abort function
 * return boolean return true if abort
 */
global block AbortFunction = nil;

/**
 * Data was modified?
 */
global boolean modified = false;

/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
global boolean write_only = false;

/**
 * Read all ntp-client settings
 * @return true on success
 */

global boolean start_at_boot = false;

global list peers = [];

global integer selected_item_index = -1;

global map selected_item = $[];

list rw_order = [ "server", "fudge", "peer", "broadcast", "broadcastclient" ];

map paths = $[
    "server" : .etc.ntp_conf.server,
    "peer" : .etc.ntp_conf.peer,
    "fudge" : .etc.ntp_conf.fudge,
    "broadcast" : .etc.ntp_conf.broadcast,
    "broadcastclient" : .etc.ntp_conf.broadcastclient,
];


/**
 * Read all ntp-client settings
 * @return true on success
 */
global define boolean Read() ``{

    /* NtpClient read dialog caption */
    string caption = _("Initializing NTP Client Configuration");

    integer steps = 2;
    integer sl = 500;

    // We do not set help text here, because it was set outside
    Progress::New( caption, " ", steps, [
	    // progress stage
	    _("Read NTP settings"),
	], [
	    // progress step
	    _("Reading NTP settings..."),
	    // progress step
	    _("Finished")
	],
	""
    );

    // read current settings
    if(Abort()) return false;
    Progress::NextStage();

    boolean failed = false;

    if (! Require::AreAllPackagesInstalled (["xntp"]) || Mode::config)
    {
	boolean install_ok = Require::RequireAndConflictTarget (["xntp"], [],
	    // richtext, %1 is name of package
	    _("For network time synchronization, an XNTP daemon is required.
YaST2 will install package %1.
"));
	if (! install_ok && ! Require::LastOperationCanceled ())
	{
	    // error popup
	    Report::Error (_("Installing required packages failed."));
	}
    }

    start_at_boot = Runlevel::ServiceEnabled ("xntpd");
    peers = [];
    foreach (`k, rw_order, ``{
	path v = paths[k]:nil;
	list l = SCR::Read (v);
	if (l == nil)
	{
	    y2error ("Reading %1 returned nil", v);
	    failed = true;
	    l = [];
	}
	list(map) p = maplist (list e, l, ``(
	    $[
		"key" : k,
		"value" : e[0]:"",
		"param" : e[1]:"",
	    ]
	));
//	l = maplist (`e, l, ``(prepend (e, k)));
	peers = merge (peers, p);
    });

    string initial_sync = SCR::Read (.sysconfig.xntp.XNTPD_INITIAL_NTPDATE);
    if (initial_sync == nil)
    {
	initial_sync = "";
	failed = true;
	y2error ("Failed reading .sysconfig.xntp.XNTPD_INITIAL_NTPDATE");
    }

    if (initial_sync == "AUTO")
    {
	peers = maplist (`p, peers, ``{
	    p["initial"] = p["key"]:"" == "server";
	    return p;
	});
    }
    else if (regexpmatch (initial_sync, "AUTO-[0-9]+"))
    {
	integer count = tointeger (
	    regexpsub (initial_sync, "AUTO-([0-9]+)", "\\1"));
	peers = maplist (`p, peers, ``{
	    if ((p["key"]:"" == "server"
		    && ! regexpmatch (p["value"]:"",
			"^127\.127\.[0-9]+.[0-9]+$"))
		|| p["key"]:"" == "peer")
	    {
		count = count - 1;
		p["initial"] = count >= 0;
	    }
	    else
		p["initial"] = false;
	    return p;
	});
    }
    else
    {
	list listed = splitstring (initial_sync, " ");
	peers = maplist (`p, peers, ``{
	    p["initial"] = (p["key"]:"" == "server" || p["key"]:"" == "peer")
		&& contains (listed, p["value"]:"");
	    return p;
	});
    }

    peers = maplist (`p, peers, ``{
	if (p["key"]:"" == "server"
	    && regexpmatch (p["value"]:"", "^127\.127\.[0-9]+.[0-9]+$"))
	{
	    p["key"] = "radio";
	}
	return p;
    });

    y2milestone ("Read settings: %1", peers);

    if(failed)
    {
	// error report
	Report::Error(_("Cannot read the current settings."));
    }

    if(Abort()) return false;
    Progress::NextStage ();
    Progress::Title (_("Finished"));
    sleep(sl);

    if(Abort()) return false;
    modified = false;
    return true;
}

/**
 * Write all ntp-client settings
 * @return true on success
 */
global define boolean Write() ``{

    /* NtpClient read dialog caption */
    string caption = _("Saving NTP Client Configuration");

    integer steps = 2;

    integer sl = 0;
    sleep(sl);

    // We do not set help text here, because it was set outside
    Progress::New(caption, " ", steps, [
	    // progress stage
	    _("Write NTP settings"),
	    // progress stage
	    _("Restart XNTP daemon")
	], [
	    // progress step
	    _("Writing the settings..."),
	    // progress step
	    _("Restarting XNTP daemon..."),
	    // progress step
	    _("Finished")
	],
	""
    );

    // write settings
    if(Abort()) return false;
    Progress::NextStage();

    y2milestone ("Writing settings %1", peers);

    boolean failed = false;
    list(map) peers2 = maplist (`p, peers, ``{
	if (p["key"]:"" == "radio")
	    p["key"] = "server";
	return p;
    });
    foreach (`k, rw_order, ``{
	path v = paths[k]:nil;
	list(map) l = filter (map e, peers2, ``(e["key"]:"" == k));
	list(list) l2 = maplist (`e, l, ``(
	    [e["value"]:"", e["param"]:""]
	));
	boolean b = SCR::Write (v, l2);
	if (! b)
	{
	    y2error ("Writing %1 failed", v);
	    failed = true;
	    l = [];
	}
    });
    failed = failed || ! SCR::Write (.etc.ntp_conf, nil);

    if (failed)
	// error report
	Report::Error (_("Cannot write settings to /etc/ntp.conf."));


    list init = maplist (`p, peers2, ``(
	(p["key"]:"" == "server" || p["key"]:"" == "peer") && p["initial"]:false
	    ? p["value"]:""
	    : nil
    ));
    init = filter (`i, init, ``(i != nil));
    string init_str = mergestring (init, " ");

    // Don't remove the AUTO key, something should be present for initialization
    // if there is no NTP server set explicitly
    if (size (init) == 0)
    {
	string orig_init = SCR::Read (.sysconfig.xntp.XNTPD_INITIAL_NTPDATE);
	if (orig_init == "AUTO" || substring (orig_init, 0, 5) == "AUTO-")
	{
	    init_str = orig_init;
	}
    }

    if (! (SCR::Write (.sysconfig.xntp.XNTPD_INITIAL_NTPDATE, init_str)
	&& SCR::Write (.sysconfig.xntp, nil)))
    {
	// error report
	Report::Error (_("Cannot write sysconfig variables."));
    }

    sleep(sl);

    // restart daemon
    if(Abort()) return false;
    Progress::NextStage ();

    if (! Runlevel::ServiceAdjust ("xntpd",
	start_at_boot ? "enable" : "disable"))
    {
	// error report
	Report::Error (_("Cannot adjust the service"));
    }
    if (start_at_boot && (! write_only)
	&& 0 != Runlevel::RunInitScript("xntpd", "restart"))
    {
	// error report
	Report::Error (_("Cannot restart the XNTP daemon."));
    }
    if (! start_at_boot)
    {
	Runlevel::RunInitScript("xntpd", "stop");
    }

    sleep(sl);

    if(Abort()) return false;
    Progress::NextStage ();
    Progress::Title (_("Finished"));
    sleep(sl);

    if(Abort()) return false;
    return true;
}

/**
 * Get all ntp-client settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global define boolean Import (map settings) ``{
    start_at_boot = settings["start_at_boot"]:false;
    peers = settings["peers"]:[];
    modified = true;
    return true;
}

/**
 * Dump the ntp-client settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global define map Export () ``{
    return $[
	"start_at_boot" : start_at_boot,
	"peers" : peers,
    ];
}

/**
 * Create a textual summary and a list of unconfigured cards
 * @return list summary of the current configuration
 */
global define list Summary() ``{
    list ret = [];
    if (start_at_boot)
	// summary string
	ret = [_("The XNTP daemon starts when starting the system") ];
    else
	// summary string
	ret = [_("The XNTP daemon does not start automatically") ];

    map types = $[
	// summary string, %1 is list of addresses
	"server" : _("Servers: %1"),
	// summary string, %1 is list of addresses
	"radio" : _("Radio Clocks: %1"),
	// summary string, %1 is list of addresses
	"peer" : _("Peers: %1"),
	// summary string, %1 is list of addresses
	"broadcast" : _("Broadcast time information to: %1"),
	// summary string, %1 is list of addresses
	"broadcastclient" : _("Accept broadcasted time information from: %1"),
    ];
    foreach (`t, ["server", "radio", "peer", "broadcast", "broadcastclient" ],
    ``{
	list l = filter (`p, peers, ``(p["key"]:"" == t));
	list names = maplist (`i, l, ``(i["value"]:""));
	names = filter (`n, names, ``(n != ""));
	if (size (names) > 0)
	    ret = add (ret, sformat (types[t]:"", mergestring (names, ", ")));
    });
    return ret;
}

/* EOF */
}
