/**
 * File:	modules/NtpClient.ycp
 * Package:	Configuration of ntp-client
 * Summary:	Data for configuration of ntp-client, input and output functions.
 * Authors:	Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of ntp-client.
 * Input and output routines.
 */

{

module "NtpClient";
textdomain "ntp-client";

import "Progress";
import "Report";
import "Summary";
import "Runlevel";
import "Require";
import "Mode";

include "ntp-client/widgets.ycp";
include "ntp-client/misc.ycp";

global map widgets = InitWidgets ();

/**
 * Abort function
 * return boolean return true if abort
 */
global block AbortFunction = nil;

/**
 * Data was modified?
 */
global boolean modified = false;

/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
global boolean write_only = false;

/**
 * Read all ntp-client settings
 * @return true on success
 */

global boolean start_at_boot = false;

global list peers = [];

global integer selected_item_index = -1;

global list selected_item = [];

list rw_order = [ "server", "fudge", "peer", "broadcast", "broadcastclient" ];

map paths = $[
    "server" : .etc.ntp_conf.server,
    "peer" : .etc.ntp_conf.peer,
    "fudge" : .etc.ntp_conf.fudge,
    "broadcast" : .etc.ntp_conf.broadcast,
    "broadcastclient" : .etc.ntp_conf.broadcastclient,
];


/**
 * Read all ntp-client settings
 * @return true on success
 */
global define boolean Read() ``{

    /* NtpClient read dialog caption */
    string caption = _("Initializing ntp-client configuration");

    integer steps = 2;
    integer sl = 500;

    // We do not set help text here, because it was set outside
    Progress::New( caption, " ", steps, [
	    // progress stage
	    _("Read NTP settings"),
	], [
	    // progress step
	    _("Reading NTP settings..."),
	    // progress step
	    _("Finished")
	],
	""
    );

    // read current settings
    if(Abort()) return false;
    Progress::NextStage();

    boolean failed = false;

    if (! Require::IsPackageInstalled ("xntp") || Mode::config)
	Require::RequireAndConflictTarget (["xntp"], [],
	    // richtext, %1 is name of package
	    _("For network time synchronizxation NTP daemon is required.
YaST2 will install package %1."));

    start_at_boot = Runlevel::ServiceEnabled ("xntpd");
    peers = [];
    foreach (`k, rw_order, ``{
	path v = paths[k]:nil;
	list l = SCR::Read (v);
	if (l == nil)
	{
	    y2error ("Reading %1 returned nil", v);
	    failed = true;
	    l = [];
	}
	l = maplist (`e, l, ``(prepend (e, k)));
	peers = merge (peers, l);
    });

    string initial_sync = SCR::Read (.sysconfig.xntp.XNTPD_INITIAL_NTPDATE);
    if (initial_sync == nil)
    {
	initial_sync = "";
	failed = true;
	y2error ("Failed reading .sysconfig.xntp.XNTPD_INITIAL_NTPDATE");
    }

    if (initial_sync == "AUTO")
    {
	peers = maplist (`p, peers, ``{
	    p[3] = p[0]:"" == "server";
	    return p;
	});
    }
    else if (regexpmatch (initial_sync, "AUTO-[0-9]+"))
    {
	integer count = tointeger (
	    regexpsub (initial_sync, "AUTO-([0-9]+)", "\\1"));
	peers = maplist (`p, peers, ``{
	    if ((p[0]:"" == "server"
		    && ! regexpmatch (p[1]:"", "^127\.127\.[0-9]+.[0-9]+$"))
		|| p[0]:"" == "peer")
	    {
		count = count - 1;
		p[3] = count >= 0;
	    }
	    else
		p[3] = false;
	    return p;
	});
    }
    else
    {
	list listed = splitstring (initial_sync, " ");
	peers = maplist (`p, peers, ``{
	    p[3] = p[0]:"" == "server" && contains (listed, p[1]:"");
	    return p;
	});
    }

    peers = maplist (`p, peers, ``{
	if (p[0]:"" == "server"
	    && regexpmatch (p[1]:"", "^127\.127\.[0-9]+.[0-9]+$"))
	{
	    p[0] = "radio";
	}
	return p;
    });

    y2milestone ("Read settings: %1", peers);

    if(failed)
    {
	// error report
	Report::Error(_("Can not read current settings!"));
    }

    if(Abort()) return false;
    Progress::NextStage ();
    Progress::Title (_("Finished"));
    sleep(sl);

    if(Abort()) return false;
    modified = false;
    return true;
}

/**
 * Write all ntp-client settings
 * @return true on success
 */
global define boolean Write() ``{

    /* NtpClient read dialog caption */
    string caption = _("Saving ntp-client configuration");

    integer steps = 2;

    integer sl = 0;
    sleep(sl);

    // We do not set help text here, because it was set outside
    Progress::New(caption, " ", steps, [
	    // progress stage
	    _("Write NTP settings"),
	    // progress stage
	    _("Restart NTP daemon")
	], [
	    // progress step
	    _("Writing the settings..."),
	    // progress step
	    _("Restarting NTP daemon..."),
	    // progress step
	    _("Finished")
	],
	""
    );

    // write settings
    if(Abort()) return false;
    Progress::NextStage();

    y2milestone ("Writing settings %1", peers);

    boolean failed = false;
    list peers2 = maplist (`p, peers, ``{
	if (p[0]:"" == "radio")
	    p[0] = "server";
	return p;
    });
    foreach (`k, rw_order, ``{
	path v = paths[k]:nil;
	list l = filter (`e, peers2, ``(e[0]:"" == k));
	l = maplist (`e, l, ``(
	    [e[1]:"", e[2]:""]
	));
	boolean b = SCR::Write (v, l);
	if (! b)
	{
	    y2error ("Writing %1 failed", v);
	    failed = true;
	    l = [];
	}
    });
    failed = failed || ! SCR::Write (.etc.ntp_conf, nil);

    if (failed)
	// error report
	Report::Error (_("Can not write settings to /etc/ntp.conf!"));


    list init = maplist (`p, peers2, ``(
	p[0]:"" == "server" && p[3]:false
	    ? p[1]:""
	    : nil
    ));
    init = filter (`i, init, ``(i != nil));

    string init_str = mergestring (init, " ");
    if (! (SCR::Write (.sysconfig.xntp.XNTPD_INITIAL_NTPDATE, init_str)
	&& SCR::Write (.sysconfig.xntp, nil)))
    {
	// error report
	Report::Error (_("Can not write sysconfig variables."));
    }

    sleep(sl);

    // restart daemon
    if(Abort()) return false;
    Progress::NextStage ();

    if (! Runlevel::ServiceAdjust ("xntpd",
	start_at_boot ? "enable" : "disable"))
    {
	// error report
	Report::Error (_("Can not adjust the service"));
    }
    if (start_at_boot && (! write_only)
	&& 0 != Runlevel::RunInitScript("xntpd", "restart"))
    {
	// error report
	Report::Error (_("Can not restart NTP daemon!"));
    }

    sleep(sl);

    if(Abort()) return false;
    Progress::NextStage ();
    Progress::Title (_("Finished"));
    sleep(sl);

    if(Abort()) return false;
    return true;
}

/**
 * Get all ntp-client settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global define boolean Import (map settings) ``{
    start_at_boot = settings["start_at_boot"]:false;
    peers = settings["peers"]:[];
    modified = true;
    return true;
}

/**
 * Dump the ntp-client settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global define map Export () ``{
    return $[
	"start_at_boot" : start_at_boot,
	"peers" : peers,
    ];
}

/**
 * Create a textual summary and a list of unconfigured cards
 * @param split split configured and unconfigured?
 * @return summary of the current configuration
 */
global define list Summary() ``{
    list ret = [];
    if (start_at_boot)
	// summary string
	ret = [_("Start XNTP daemon when starting system") ];
    else
	// summary string
	ret = [_("Do not start XNTP daemon automatically") ];

    map types = $[
	// summary string, %1 is list of addresses
	"server" : _("Servers: %1"),
	// summary string, %1 is list of addresses
	"radio" : _("Radio clocks: %1"),
	// summary string, %1 is list of addresses
	"peer" : _("Peers: %1"),
	// summary string, %1 is list of addresses
	"broadcast" : _("Broadcast to: %1"),
	// summary string, %1 is list of addresses
	"broadcastclient" : _("Accept broadcasts from: %1"),
    ];
    foreach (`t, ["server", "radio", "peer", "broadcast", "broadcastclient" ],
    ``{
	list l = filter (`p, peers, ``(p[0]:"" == t));
	list names = maplist (`i, l, ``(i[1]:""));
	names = filter (`n, names, ``(n != ""));
	if (size (names) > 0)
	    ret = add (ret, sformat (types[t]:"", mergestring (names, ", ")));
    });
    return ret;
}

/* EOF */
}
