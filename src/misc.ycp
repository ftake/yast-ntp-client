/**
 * File:	include/ntp-client/misc.ycp
 * Package:	Configuration of ntp-client
 * Summary:	Miscelanous functions for configuration of ntp-client.
 * Authors:	Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 */

{

textdomain "ntp-client";

import "IP";
import "Popup";
import "Progress";
import "Service";

include "ntp-client/clocktypes.ycp";

/**
 * Ask user if exit without saving
 * @return boolean true if exit
 */
define boolean reallyExit () ``{
    // yes-no popup
    return Popup::YesNo (_("Really exit?
All changes will be lost."));
}

define void restartNtpDaemon () ``{
    Service::RunInitScript("xntpd", "restart");
}

define void silentWrite () ``{
    Progress::off ();
    NtpClient::Write ();
    Progress::on ();
}

/**
 * Parse string to map of options
 * @param options_string string of options
 * @return map options as a map
 */
define map string2opts (string options_string, list<string> with_param,
        list<string>without_param)
    ``{
    list<string> l = splitstring (options_string, " ");
    l = filter (string e, l, ``(e != ""));
    boolean ignore_next = false;
    integer index = -1;
    list<string> unknown = [];
    map<string,any> ret = (map<string,any>)listmap (string e, l, ``{
	index = index + 1;
	if (ignore_next)
	{
	    ignore_next = false;
	    return $[ e : (any)nil ];
	}
	ignore_next = false;
	if (contains (with_param, e))
	{
	    ignore_next = true;
	    return $[ e: l[index + 1]:""];
	}
	else if (contains (without_param, e))
	{
	    return $[ e : true ];
	}
	else
	{
	    unknown = add (unknown, e);
	    return $[ e : (any)nil];
	}
    });
    ret = (map<string,any>)filter (string k, any v, ret, ``(v != nil));
    ret = $[
	"parsed" : ret,
	"unknown" : mergestring (unknown, " "),
    ];
    return ret;
}

/**
 * Create options string from a map
 * @param options map options represented as a map
 * @return string options represented as a string
 */
define string opts2string (map options, string other) ``{
    string ret = other;
    foreach (string k, any v, options, ``{
	if (v == true)
	{
	    ret = sformat ("%1 %2", ret, k);
	}
	else if (v != false && v != "")
	{
	    ret = sformat ("%1 %2 %3", ret, k, v);
	}
    });
    return ret;
}

/**
 * If modified, ask for confirmation
 * @return true if abort is confirmed
 */
define boolean ReallyAbort() ``{
    return !NtpClient::modified || Popup::ReallyAbort(true);
}

/**
 * Abort function
 * @return blah blah lahjk
 */
define boolean Abort() ``{
    if(NtpClient::AbortFunction != nil)
	return eval(NtpClient::AbortFunction) == true;
    return false;
}

/**
 * Check for pending Abort press
 * @return true if pending abort
 */
define boolean PollAbort() ``{
    return UI::PollInput() == `abort;
}

/**
  * Get the type of the clock from the address
  * @param address string the clock identification in the IP address form
  * @return integer the clock type
  */
define integer getClockType (string address) ``{
    if (address == "")
	return 0;
    if (! IP::Check4 (address))
    {
	y2error ("Invalid address: %1", address);
	return nil;
    }
    string cl_type = regexpsub (address,
	"[0-9]+\.[0-9]+\.([0-9]+)\.[0-9]+",
	"\\1");
    return tointeger (cl_type);
}

define string setClockType (string address, integer clock_type) ``{
    if (address == "")
	address = "127.127.0.0";
    if (! IP::Check4 (address))
    {
	y2error ("Invalid address: %1", address);
	return nil;
    }
    string ret = regexpsub (address,
	"([0-9]+\.[0-9]+\.)[0-9]+(\.[0-9]+)",
	sformat ("\\1%1\\2", clock_type));
    y2error ("Ret: %1", ret);
    return ret;
}

/**
  * Get the unit number of the clock from the address
  * @param address string the clock identification in the IP address form
  * @return integer the unit number
  */
define integer getClockUnitNumber (string address) ``{
    if (address == "")
	return 0;
    if (! IP::Check4 (address))
    {
	y2error ("Invalid address: %1", address);
	return nil;
    }
    string cl_type = regexpsub (address,
	"[0-9]+\.[0-9]+\.[0-9]+\.([0-9]+)",
	"\\1");
    return tointeger (cl_type);
}

define string setClockUnitNumber (string address, integer unit_number) ``{
    if (address == "")
	address = "127.127.0.0";
    if (! IP::Check4 (address))
    {
	y2error ("Invalid address: %1", address);
	return nil;
    }
    string ret = regexpsub (address,
	"([0-9]+\.[0-9]+\.[0-9]+\.)[0-9]+",
	sformat ("\\1%1", unit_number));
    y2error ("Ret: %1", ret);
    return ret;
}


/**
  * Get entries for the clock type combo box
  * @return list of items for the combo box
  */
define list getClockTypesCombo () ``{
    map clock_names = mapmap (integer k, map<string,string> v, clock_types, ``(
	    $[ k: v["name"]:"" ]
	)
    );
    list ret = maplist (string k, string v, clock_names, ``(
	`item (sformat ("%1", k), v)
    ));
    return ret;
}

define void proposeInterfacesToAllowAccess () ``{
    list<map<string,any> > recs = NtpClient::getSyncRecords ();
    recs = filter (map<string,any> r, recs, ``(
	r["type"]:"" == "peer" || r["type"]:"" == "broadcastclient"
    ));
    list<string> addresses = maplist (map<string,any> r, recs, ``(
	r["address"]:""
    ));
    addresses = filter (string a, addresses, ``(a != "" && a != nil));
    addresses = maplist (string a, addresses, ``{
	if (IP::Check4 (a))
	    return a;
	map m = (map)SCR::Execute (.target.bash_output,
	    sformat ("/usr/bin/host %1 | /bin/grep address", a));
	if (m["exit"]:0 != 0)
	    return nil;
	string out = m["stdout"]:"";
	out = regexpsub (out, "has address (.*)$", "\\1");
	return out;
    });
    addresses = filter (string a, addresses, ``(a != "" && a != nil));
    list<string> ifaces = maplist (string a, addresses, ``{
	map m = (map)SCR::Execute (.target.bash_output,
	    sformat ("/sbin/ip route get %1", a));
	if (m["exit"]:0 != 0)
	    return nil;
	string out = m["stdout"]:"";
	out = mergestring (splitstring (out, "\n"), " ");
	out = regexpsub (out, "dev[ ]+([^ ]+)[ ]+src", "\\1");
	return out;
    });
y2error ("Ifaces: %1", ifaces);
    foreach (string ic, ["EXT", "INT", "DMZ"], ``{
	NtpClient::firewall_settings[ic] = false;
	string k = sformat ("FW_DEV_%1", ic);
	string s = SuSEFirewall::settings[k]:"";
	list<string> l = splitstring (s, " ");
	foreach (string i, ifaces, ``{
	    if (contains (l, i))
		NtpClient::firewall_settings[ic] = true;
	});
    });
y2error ("FS: %1", NtpClient::firewall_settings);
}

/* EOF */
}
